//
// conventions
//     left = coord.x - 1
//     right = coord.x + 1
//     top = coord.y + 1
//     bottom = coord.y - 1
//

RWTexture2D<float4> PrecipMask;  //defines where rainfall will occur
RWTexture2D<float4> ReposeMask;
RWTexture2D<float>  Collision;

RWTexture2D<float>  TerrainHeight;      //terrain heightmap
RWTexture2D<float>  TerrainHeightPrev;  //previous frame

RWTexture2D<float>  Water;       //water height
RWTexture2D<float>  WaterPrev;   //water height prev

RWTexture2D<float2> WaterVel;    //water velocity
RWTexture2D<float2> WaterVelPrev; //water vel prev

RWTexture2D<float4> Flux;        //current water flux (how much water is transferring to neighboring cells)
RWTexture2D<float4> FluxPrev;    //flux

RWTexture2D<float>  Sediment;    //suspended sediment concentration (being transported by the water)
RWTexture2D<float>  SedimentPrev;

float dt;                    //the time step for the simulation
float precipRate;            //the rate at which we will add water via rainfall
float flowRate;              //how fast water flows
float sedimentCapacity;
float sedimentDissolveRate;
float sedimentDepositRate;
float evaporationRate;

float4 texDim;     //the dimensions of all of our textures (they must all be the same dimensions)
float3 terrainDim; //the dimensions of the terrain in world units

uint4 getSafeNeighbors(uint2 coord) {
	return uint4(
		(coord.x < (uint)texDim[0] - 1) ? coord.x + 1 : coord.x,  //right index
		(coord.x > 0) ? coord.x - 1 : coord.x,                    //left index
		(coord.y < (uint)texDim[1] - 1) ? coord.y + 1 : coord.y,  //top index
		(coord.y > 0) ? coord.y - 1 : coord.y                     //bottom index
		);
}

//use WaterPrev here because we have not yet calculated this frame's buffer
float4 simulateFlux(uint2 coord) {
	float cellSize = 0.01f;
	float g = -9.8f;
	float h = TerrainHeightPrev[coord] + WaterPrev[coord];

	uint4 nidx = getSafeNeighbors(coord);
	
	float fluxCapacitance = (dt * flowRate * g) / cellSize;

	//left
	float4 outFlux;
	float dh = h - (TerrainHeightPrev[uint2(nidx.y, coord.y)] + WaterPrev[uint2(nidx.y, coord.y)]);
	outFlux.x = max(0.0f, FluxPrev[coord].x + dh * fluxCapacitance);

	//right
	dh = h - (TerrainHeightPrev[uint2(nidx.x, coord.y)] + WaterPrev[uint2(nidx.x, coord.y)]);
	outFlux.y = max(0.0f, FluxPrev[coord].y + dh * fluxCapacitance);

	//top
	dh = h - (TerrainHeightPrev[uint2(coord.x, nidx.z)] + WaterPrev[uint2(coord.x, nidx.z)]);
	outFlux.z = max(0.0f, FluxPrev[coord].z + dh * fluxCapacitance);

	//bottom
	dh = h - (TerrainHeightPrev[uint2(coord.x, nidx.w)] + WaterPrev[uint2(coord.x, nidx.w)]);
	outFlux.w = max(0.0f, FluxPrev[coord].w + dh * fluxCapacitance);

	return outFlux;
}

float2 simulateWaterVelocity(uint2 coord) {
	uint4 nidx = getSafeNeighbors(coord);

	//use flux here because we've already computed this for this frame
	float inFlow = Flux[uint2(nidx.y, coord.y)].y +
				   Flux[uint2(nidx.x, coord.y)].x +
				   Flux[uint2(coord.x, nidx.w)].z +
				   Flux[uint2(coord.x, nidx.z)].w;

	float outFlow = Flux[coord].x + Flux[coord].y + Flux[coord].z + Flux[coord].w;

	float dx = 1.0f / texDim[0];
	float dy = 1.0f / texDim[1]; 

	float dV = dt * (inFlow - outFlow);
	float waterNew = WaterPrev[coord] + dV / (dx * dy);
	Water[coord] = max(0.0f, waterNew);

	//update velocities
	float meanWater = 0.5f * (WaterPrev[coord] + Water[coord]);
	float2 newWaterVel;
	if (meanWater == 0.0f) {
		newWaterVel = float2(0.0f, 0.0f);
	}
	else {
		//I'm not confident on this line - should this be 1/meanWater or meanWater???
		meanWater = 1.0f / meanWater;
		newWaterVel.x = meanWater * 0.5f * (Flux[uint2(nidx.y, coord.y)].y - Flux[coord].x - Flux[uint2(nidx.x, coord.y)].x + Flux[coord].y) / (dy);
		newWaterVel.y = meanWater * 0.5f * (Flux[uint2(coord.x, nidx.w)].z - Flux[coord].w - Flux[uint2(coord.x, nidx.z)].w + Flux[coord].z) / (dx);
	}

	return newWaterVel;
}

float hash(float n)
{
	return frac(sin(n)*43758.5453f);
}

float noise(float3 x)
{
	float3 p = floor(x);
	float3 f = frac(x);

	f = f * f * (3.0 - 2.0 * f);

	float n = p.x + p.y * 57.0 + 113.0 * p.z;

	float res = lerp(lerp(lerp(hash(n + 0.0), hash(n + 1.0), f.x),
		lerp(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
		lerp(lerp(hash(n + 113.0), hash(n + 114.0), f.x),
			lerp(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
	return res;
}

float fbm(float3 p)
{
	float f;
	f = 0.5000*noise(p); p = p * 2.02;
	//f += 0.2500*noise(p); p = p * 2.03;
	//f += 0.1250*noise(p);
	return f;
}

float rainPosition;
void simulateWater(uint2 coord) {
	//rainfall
	float rainScale = 0.03f;
	float3 rainPos = float3(rainScale * (float)coord.x, rainScale * (float)coord.y, rainPosition);
	float rainfall = precipRate * dt * fbm(rainPos);// *PrecipMask[coord].r;

	float evaporated = evaporationRate * dt;

	Flux[coord] = simulateFlux(coord);
	WaterVel[coord] = simulateWaterVelocity(coord);

	Water[coord] = max(WaterPrev[coord] + rainfall - evaporated, 0.0f);
}

#pragma kernel SimulateWaterFlow

[numthreads(8,8,1)]
void SimulateWaterFlow(uint3 id : SV_DispatchThreadID)
{
	simulateWater(id.xy);
}


//
// Hydraulic Erosion
//
void simulateErosion(uint2 coord) {
	float kc = sedimentCapacity;        // sediment capacity
	float ks = sedimentDissolveRate;    // dissolving constant
	float kd = sedimentDepositRate;     // deposition constant

	float waterLevel = Water[coord];    //use Water, not WaterPrev here because we have just simulated water flow
	float sediment = SedimentPrev[coord];
	float terrainHeight = TerrainHeightPrev[coord];

	uint4 nidx = getSafeNeighbors(coord);

	float3 n = float3(TerrainHeightPrev[uint2(nidx.x, coord.y)] - TerrainHeightPrev[uint2(nidx.y, coord.y)],
					  TerrainHeightPrev[uint2(coord.x, nidx.z)] - TerrainHeightPrev[uint2(coord.x, nidx.w)],
					  2.0f);
	n = normalize(n);
	float cosa = dot(n, float3(0.0f, 0.0f, 1.0f));
	float sinAlpha = max(0.1f, sin(acos(cosa)));

	//use watervel here because we have just computed it for this frame in the previous stage
	float flowSpeed = sqrt(WaterVel[coord].x * WaterVel[coord].x + WaterVel[coord].y * WaterVel[coord].y);

	//local sediment capacity of the flow
	float cap = kc * flowSpeed * sinAlpha * (min(Water[coord], 0.01f) / 0.01f);
	float delta = (cap - SedimentPrev[coord]);

	float fctr = min(Water[coord], 0.01f) / 0.01f;

	if (delta > 0.0f) {
		//pick up sediment
		float d = ks * delta;
		TerrainHeight[coord] = saturate(terrainHeight - d);
		Water[coord] = saturate(waterLevel + d);
		Sediment[coord] = saturate(sediment + d);
	}
	else
	{
		//deposit sediment
		float d = kd * delta;
		TerrainHeight[coord] = terrainHeight + d;
		Water[coord] = saturate(waterLevel - d);
		Sediment[coord] = saturate(sediment - d);
	}
}

void simulateSedimentTransport(uint2 coord) {
	//use WaterVel not WaterVelPrev because we calculated it in the previous stage
	float velScalar = 0.01f; //should be a setting?
	float fromX = (float)coord.x - velScalar * WaterVel[coord].x;
	float fromY = (float)coord.y - velScalar * WaterVel[coord].y;

	//boundary conditions
	if (fromX < 0.0f) { fromX = 0.0f; }
	if (fromX >= (float)(texDim[0] - 1)) { fromX = (float)texDim[0] - 1.0f; }

	if (fromY < 0) { fromY = 0.0f; }
	if (fromY >= (float)(texDim[1] - 1)) { fromY = (float)texDim[1] - 1.0f; }
	

	uint2 cell0 = uint2((uint)fromX, (uint)fromY);
	uint2 cell1 = cell0 + uint2(1, 1);

	float fx = fromX - (float)cell0.x;
	float fy = fromY - (float)cell0.y;

	Sediment[coord] = lerp(lerp(SedimentPrev[cell0], SedimentPrev[uint2(cell1.x, cell0.y)], fx), lerp(SedimentPrev[uint2(cell0.x, cell1.y)], SedimentPrev[cell1], fx), fy);
}

#pragma kernel HydraulicErosion

[numthreads(8,8,1)]
void HydraulicErosion (uint3 id : SV_DispatchThreadID)
{	
	simulateErosion(id.xy);
	simulateSedimentTransport(id.xy);
}


//
// Thermal Erosion
//
float4 angleOfRepose; //actually tan(theta), which is slope (m)
float4 dxdy; //<dx, dy, dxy, 0.0>
int numThermalIterations;

void simulateThermalErosion(uint2 coord) {
	/*if (coord.x <= 0 || coord.x > (uint)texDim[0] || coord.y <= 0 || coord.y > (uint)texDim[1]) {
		return;
	}*/

	if (Collision[coord] > 0.5f) {
		return;
	}

	float h = TerrainHeightPrev[coord];

	float dhl = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x - 1, coord.y)]);
	float dhr = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x + 1, coord.y)]);
	float dht = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x, coord.y + 1)]);
	float dhb = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x, coord.y - 1)]);

	float dhtl = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x - 1, coord.y + 1)]);
	float dhtr = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x + 1, coord.y + 1)]);
	float dhbl = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x - 1, coord.y - 1)]);
	float dhbr = terrainDim[1] * (h - TerrainHeightPrev[uint2(coord.x + 1, coord.y - 1)]);

	if (Collision[uint2(coord.x - 1, coord.y)] > 0.5f || coord.x == 0) { dhl = 0.0f; }
	if (Collision[uint2(coord.x + 1, coord.y)] > 0.5f || coord.x == (uint)texDim[0]) { dhr = 0.0f; }
	if (Collision[uint2(coord.x, coord.y - 1)] > 0.5f || coord.y == 0) { dhb = 0.0f; }
	if (Collision[uint2(coord.x, coord.y + 1)] > 0.5f || coord.y == (uint)texDim[1]) { dht = 0.0f; }

	if (Collision[uint2(coord.x - 1, coord.y + 1)] > 0.5f) { dhtl = 0.0f; }
	if (Collision[uint2(coord.x + 1, coord.y + 1)] > 0.5f) { dhtr = 0.0f; }
	if (Collision[uint2(coord.x - 1, coord.y - 1)] > 0.5f) { dhbl = 0.0f; }
	if (Collision[uint2(coord.x + 1, coord.y - 1)] > 0.5f) { dhbr = 0.0f; }
	
	float ml = abs(dhl / dxdy.x);
	float mr = abs(dhr / dxdy.x);
	float mt = abs(dhr / dxdy.y);
	float mb = abs(dhb / dxdy.y);

	float mtl = abs(dhtl / dxdy.z);
	float mtr = abs(dhtr / dxdy.z);
	float mbl = abs(dhbl / dxdy.z);
	float mbr = abs(dhbr / dxdy.z);

	float tau = lerp(angleOfRepose.x, angleOfRepose.y, ReposeMask[coord].x);

	float dv = 0; //volume of sediment moved
	float r = 16.0f;
	if (ml > tau) { dv += (dhl / r); }
	if (mr > tau) { dv += (dhr / r); }
	if (mt > tau) { dv += (dht / r); }
	if (mb > tau) { dv += (dhb / r); }

	if (mtl > tau) { dv += (dhtl / r); }
	if (mtr > tau) { dv += (dhtr / r); }
	if (mbl > tau) { dv += (dhbl / r); }
	if (mbr > tau) { dv += (dhbr / r); }

	TerrainHeight[coord] -= dt * dv;
	Sediment[coord] = SedimentPrev[coord] + dt * dv;
}

//
// diffuse / blur height
//

void diffuseHeight(uint2 coord, float amt, int iterations) {
	//for (int i = 0; i < iterations; i++) {
		float left = TerrainHeightPrev[uint2(coord.x - 1, coord.y)];
		float right = TerrainHeightPrev[uint2(coord.x - 1, coord.y)];
		float top = TerrainHeightPrev[uint2(coord.x, coord.y + 1)];
		float bottom = TerrainHeightPrev[uint2(coord.x, coord.y - 1)];

		TerrainHeight[coord] = lerp(TerrainHeightPrev[coord], 0.25f * (left + right + top + bottom), amt);
	//}
}

#pragma kernel ThermalErosion

[numthreads(8, 8, 1)]
void ThermalErosion(uint3 id : SV_DispatchThreadID)
{
	simulateThermalErosion(id.xy);
	//diffuseHeight(id.xy, saturate(0.0f * dt), 1);
}

#pragma kernel DiffuseHeight
[numthreads(8, 8, 1)]
void DiffuseHeight(uint3 id : SV_DispatchThreadID)
{
	diffuseHeight(id.xy, 1.0f, 100);
}