#pragma kernel HydraulicErosion

RWTexture2D<float>  TerrainHeight;    //terrain heightmap
RWTexture2D<float4> PrecipMask;  //defines where rainfall will occur
RWTexture2D<float>  Water;       //water height
RWTexture2D<float2> WaterVel;    //water velocity
RWTexture2D<float4> Flux;        //current water flux (how much water is transferring to neighboring cells)
RWTexture2D<float>  Sediment;    //suspended sediment concentration (being transported by the water)

float dt;          //the time step for the simulation
float precipRate;  //the rate at which we will add water via rainfall
float flowRate;    //how fast water flows
float sedimentCapacity;
float sedimentDissolveRate;
float sedimentDepositRate;

float4 texDim;     //the dimensions of all of our textures (they must all be the same dimensions)

float4 simulateFlux(uint2 coord) {
	float cellSize = 1.0f;
	float g = -9.8f;
	float h = TerrainHeight[coord] + Water[coord];//WaterPrev[coord];
	
	float fluxCapacitance = (dt * flowRate * g) / cellSize;

	//left
	float4 outFlux;
	float dh = h - (TerrainHeight[uint2(coord.x - 1, coord.y)] + Water[uint2(coord.x - 1, coord.y)]);
	outFlux.x = max(0.0f, Flux[coord].x + dh * fluxCapacitance);

	//right
	dh = h - (TerrainHeight[uint2(coord.x + 1, coord.y)] + Water[uint2(coord.x + 1, coord.y)]);
	outFlux.y = max(0.0f, Flux[coord].y + dh * fluxCapacitance);

	//top
	dh = h - (TerrainHeight[uint2(coord.x, coord.y + 1)] + Water[uint2(coord.x, coord.y + 1)]);
	outFlux.z = max(0.0f, Flux[coord].z + dh * fluxCapacitance);

	//bottom
	dh = h - (TerrainHeight[uint2(coord.x, coord.y - 1)] + Water[uint2(coord.x, coord.y - 1)]);
	outFlux.w = max(0.0f, Flux[coord].w + dh * fluxCapacitance);

	return outFlux;
}

float2 simulateWaterVelocity(uint2 coord) {
	float inFlow = Flux[uint2(coord.x - 1, coord.y)].y +
				   Flux[uint2(coord.x + 1, coord.y)].x +
				   Flux[uint2(coord.x, coord.y - 1)].z +
				   Flux[uint2(coord.x, coord.y + 1)].w;

	float outFlow = Flux[coord].x + Flux[coord].y + Flux[coord].z + Flux[coord].w;

	float dx = 1.0f; //grid dims?
	float dy = 1.0f; 

	float dV = dt * (inFlow - outFlow);
	float oldWater = Water[coord];
	Water[coord] += dV / (dx * dy);
	Water[coord] = max(0.0f, Water[coord]);

	//update velocities
	float meanWater = 0.5f * (oldWater + Water[coord]);
	float2 newWaterVel;
	if (meanWater == 0.0f) {
		newWaterVel = float2(0.0f, 0.0f);
	}
	else {
		//I'm not confident on this line - should this be 1/meanWater or meanWater???
		newWaterVel.x = meanWater * 0.5f * (Flux[uint2(coord.x - 1, coord.y)].y - Flux[coord].x - Flux[uint2(coord.x + 1, coord.y)].x + Flux[coord].y) / (dy);// *meanWater);
		newWaterVel.y = meanWater * 0.5f * (Flux[uint2(coord.x, coord.y - 1)].z - Flux[coord].w - Flux[uint2(coord.x, coord.y + 1)].w + Flux[coord].z) / (dx);// *meanWater);
	}

	return newWaterVel;
}

void simulateErosion(uint2 coord) {
	float kc = sedimentCapacity;     // sediment capacity
	float ks = sedimentDissolveRate;    // dissolving constant
	float kd = sedimentDepositRate;    // deposition constant

	float3 n = float3(TerrainHeight[uint2(coord.x + 1, coord.y)] - TerrainHeight[uint2(coord.x - 1, coord.y)],
					  TerrainHeight[uint2(coord.x, coord.y + 1)] - TerrainHeight[uint2(coord.x, coord.y - 1)],
					  2.0f);
	n = normalize(n);
	float cosa = dot(n, float3(0.0f, 0.0f, 1.0f));
	float sinAlpha = max(0.1f, sin(acos(cosa)));

	float flowSpeed = sqrt(WaterVel[coord].x * WaterVel[coord].x + WaterVel[coord].y * WaterVel[coord].y);

	//local sediment capacity of the flow
	float cap = kc * flowSpeed * sinAlpha * (min(Water[coord], 0.01f) / 0.01f);
	float delta = (cap - Sediment[coord]);

	float fctr = min(Water[coord], 0.01f) / 0.01f;

	if (delta > 0.0f) {
		//pick up sediment
		float d = ks * delta;
		TerrainHeight[coord] = saturate(TerrainHeight[coord] - d);
		Water[coord] = saturate(Water[coord] + d);
		Sediment[coord] = saturate(Sediment[coord] + d);
	}
	else
	{
		//deposit sediment
		float d = kd * delta;
		TerrainHeight[coord] = TerrainHeight[coord] + d;
		Water[coord] = saturate(Water[coord] - d);
		Sediment[coord] = saturate(Sediment[coord] - d);
	}
}

void simulateSedimentTransport(uint2 coord) {
	float fromX = (float)coord.x - WaterVel[coord].x;
	float fromY = (float)coord.y - WaterVel[coord].y;

	uint2 cell0 = uint2((uint)fromX, (uint)fromY);
	uint2 cell1 = cell0 + uint2(1, 1);

	float fx = fromX - (float)cell0.x;
	float fy = fromY - (float)cell0.y;

	Sediment[coord] = lerp(lerp(Sediment[cell0], Sediment[uint2(cell1.x, cell0.y)], fx), lerp(Sediment[uint2(cell0.x, cell1.y)], Sediment[cell1], fx), fy);
}

void simulateWater(uint2 coord) {
	//rainfall
	Water[coord] = Water[coord] + precipRate * dt * PrecipMask[coord].r;

	Flux[coord] = simulateFlux(coord);
	WaterVel[coord] = simulateWaterVelocity(coord);

	//evaporation
}

[numthreads(8,8,1)]
void HydraulicErosion (uint3 id : SV_DispatchThreadID)
{
	simulateWater(id.xy);
	simulateErosion(id.xy);
	simulateSedimentTransport(id.xy);
}
