// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> InHeight;
RWTexture2D<float4> PrecipMask;

// water level
//RWTexture2D<float>  WaterPrev;
RWTexture2D<float>  Water;

// water velocity
RWTexture2D<float2> WaterVelPrev;
RWTexture2D<float2> WaterVel;

RWTexture2D<float4> Flux;

float dt;
float precipRate;

float4 texDim;

//assumes that there is a linear relationship between flux and slope of the heightfield (maybe not true?)
float4 getGradients(uint2 coord) {
	float flowRate = 0.1f;

	//compute the gradients
	float dx, dy;

	//left
	dy = InHeight[coord].x - InHeight[uint2(coord.x - 1, coord.y)].x;
	float fluxLeft = flowRate * (dy * texDim[0]);

	//right
	dy = InHeight[coord].x - InHeight[uint2(coord.x + 1, coord.y)].x;
	float fluxRight = flowRate * (dy * texDim[0]);

	//top
	dy = InHeight[coord].x - InHeight[uint2(coord.x, coord.y + 1)].x;
	float fluxTop = flowRate * (dy * texDim[1]);

	//bottom
	dy = InHeight[coord].x - InHeight[uint2(coord.x, coord.y - 1)].x;
	float fluxBottom = flowRate * (dy * texDim[1]);

	return float4(fluxLeft, fluxRight, fluxTop, fluxBottom);
}

/*
float transportWater(uint2 coord, float4 flux) {
	float inFlux = flux.x + flux.y + flux.z + flux.w;
	return 0.01f * inFlux;
}
*/

float4 simulateFlux(uint2 coord) {
	float flowSpeed = -0.05f;
	float cellSize = 1.0f;
	float g = -9.8f;
	float h = InHeight[coord].r + Water[coord];//WaterPrev[coord];
	
	float fluxCapacitance = (dt * flowSpeed * g) / cellSize;

	//left
	float4 outFlux;
	float dh = h - (InHeight[uint2(coord.x - 1, coord.y)].r + Water[uint2(coord.x - 1, coord.y)]);
	outFlux.x = max(0.0f, Flux[coord].x + dh * fluxCapacitance);

	//right
	dh = h - (InHeight[uint2(coord.x + 1, coord.y)].r + Water[uint2(coord.x + 1, coord.y)]);
	outFlux.y = max(0.0f, Flux[coord].y + dh * fluxCapacitance);

	//top
	dh = h - (InHeight[uint2(coord.x, coord.y + 1)].r + Water[uint2(coord.x, coord.y + 1)]);
	outFlux.z = max(0.0f, Flux[coord].z + dh * fluxCapacitance);

	//bottom
	dh = h - (InHeight[uint2(coord.x, coord.y - 1)].r + Water[uint2(coord.x, coord.y - 1)]);
	outFlux.w = max(0.0f, Flux[coord].w + dh * fluxCapacitance);

	return outFlux;
}

void simulateWaterVelocity(uint2 coord) {
	float inFlow = Flux[uint2(coord.x - 1, coord.y)].y +
				   Flux[uint2(coord.x + 1, coord.y)].x +
				   Flux[uint2(coord.x, coord.y - 1)].z +
				   Flux[uint2(coord.x, coord.y + 1)].w;

	float outFlow = Flux[coord].x + Flux[coord].y + Flux[coord].z + Flux[coord].w;

	float dx = 1.0f; //grid dims?
	float dy = 1.0f; 

	float dV = dt * (inFlow - outFlow);
	float oldWater = Water[coord];
	Water[coord] += dV / (dx * dy);
	Water[coord] = max(0.0f, Water[coord]);

	//TODO: Update velocities
}


void simulateWater(uint2 coord) {
	//rainfall
	Water[coord] = Water[coord] + precipRate * dt * PrecipMask[coord].r;

	Flux[coord] = simulateFlux(coord);
	simulateWaterVelocity(coord);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	simulateWater(id.xy);
}
